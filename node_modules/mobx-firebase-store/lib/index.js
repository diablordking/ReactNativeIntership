'use strict';

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.ObservableSubscriptionGraph = exports.primitiveKey = undefined;

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };
//Utility to maintain nested firebase subscriptions


var _firebaseNest = require('firebase-nest');

var _firebaseNest2 = _interopRequireDefault(_firebaseNest);

var _mobx = require('mobx');

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

var map = _mobx.observable.map;
var primitiveKey = exports.primitiveKey = '_primitive';

//Firebase 3.x: snapshot.key() has been replaced with snapshot.key
var _getKey = function getKey(snapshot) {
    if (typeof snapshot.key == 'function') {
        console.log("mobx-firebase-store: detected pre-3.x firebase snapshot.key()");
        _getKey = legacyGetKey;
        return legacyGetKey(snapshot);
    }
    console.log("mobx-firebase-store: detected ^3.x firebase snapshot.key");
    _getKey = newGetKey;
    return newGetKey(snapshot);
};
function legacyGetKey(snapshot) {
    return snapshot.key();
}
function newGetKey(snapshot) {
    return snapshot.key;
}

function setData(fbStore, sub, snapshot) {
    (0, _mobx.runInAction)(function () {
        var m = fbStore.get(sub.subKey);
        if (!m) {
            m = map({});
            fbStore.set(sub.subKey, m);
        }

        m.clear();

        var oldVal = snapshot.val();
        var newVal = sub.transformValue ? sub.transformValue(oldVal) : oldVal;
        var val = newVal;
        var valTransformed = oldVal !== newVal;

        //Support primitive values by wrapping them in an object
        if (val !== null && (typeof val === 'undefined' ? 'undefined' : _typeof(val)) !== 'object') {
            m.merge(_defineProperty({}, primitiveKey, val));
        } else {
            if (valTransformed) {
                m.merge(val);
            } else {
                //Use snapshot.forEach to preserve any ordering.
                //mobx observable map preserves insertion ordering in its keys(), entries() getters

                snapshot.forEach(function (child) {
                    var childVal = child.val();
                    var newChildVal = sub.transformChild ? sub.transformChild(childVal) : childVal;
                    m.set(_getKey(child), newChildVal);
                });
            }
        }
    });
}

function setChild(fbStore, sub, snapshot) {
    (0, _mobx.runInAction)(function () {
        var record = fbStore.get(sub.subKey);
        if (!record) {
            //TODO error
            console.error('[mobx-firebase-store] setChild: ', sub, 'Can\'t find record for ' + sub.subKey);
            return;
        }

        var oldVal = snapshot.val();
        var newVal = sub.transformChild ? sub.transformChild(oldVal) : oldVal;

        record.set(_getKey(snapshot), newVal);
    });
}

function removeChild(fbStore, sub, key) {
    (0, _mobx.runInAction)(function () {
        var record = fbStore.get(sub.subKey);
        if (!record) {
            //TODO error
            console.error('[mobx-firebase-store] removeChild: ', sub, 'Can\'t find record for ' + sub.subKey);
            return;
        }

        record.delete(key);
    });
}

function defaultThrottleConfig() {
    return {
        shouldThrottle: true,
        maxQueueSize: 100,
        queueingTimeMs: 20
    };
}

var CallQueue = function () {
    function CallQueue(config) {
        _classCallCheck(this, CallQueue);

        this.queue = [];
        this.timeout = null;

        config = config || defaultThrottleConfig();
        this.shouldThrottle = config.shouldThrottle;
        this.maxQueueSize = config.maxQueueSize;
        this.queueingTimeMs = config.queueingTimeMs;
    }

    _createClass(CallQueue, [{
        key: 'add',
        value: function add(call) {
            var _this = this;

            if (!this.shouldThrottle) {
                //Not throttling, call immediately without queueing
                call();
                return;
            }

            if (this.queue.length > this.maxQueueSize) {
                this.drain();
            }
            if (this.timeout) {
                clearTimeout(this.timeout);
            }
            this.queue.push(call);
            this.timeout = setTimeout(function () {
                _this.drain();
            }, this.queueingTimeMs);
        }
    }, {
        key: 'drain',
        value: function drain() {
            var queue = this.queue.slice(0);
            this.queue = [];
            (0, _mobx.runInAction)(function () {
                (queue || []).forEach(function (call) {
                    return call();
                });
            });
        }
    }]);

    return CallQueue;
}();

function validateTransforms(sub) {
    if (sub.transformChild && sub.transformValue) {
        console.error('[mobx-firebase-store] cannot use transformChild and transformValue together; use transformChild with asList, transformValue or transformChild with asValue', sub);
    } else if (sub.asList && sub.transformValue) {
        console.error('[mobx-firebase-store] should not use transformValue with asList, use transformChild', sub);
    }
}

function createFirebaseSubscriber(store, fb, config) {
    var queue = new CallQueue((config || {}).throttle);

    var _createNestedFirebase = (0, _firebaseNest2.default)({
        onData: function onData(type, snapshot, sub) {

            function call() {
                //console.log('got value ' + type + ' subKey=' + sub.subKey + ' key=' + getKey(snapshot) + ' path=' + sub.path + ' #=' + (Object.keys(snapshot.val() || {}).length));
                var fbStore = store.fbStore;

                if (sub.asValue) {
                    setData(fbStore, sub, snapshot);
                } else if (sub.asList) {
                    switch (type) {
                        case _firebaseNest.FB_INIT_VAL:
                            setData(fbStore, sub, snapshot);
                            break;
                        case _firebaseNest.FB_CHILD_ADDED:
                        case _firebaseNest.FB_CHILD_CHANGED:
                            setChild(fbStore, sub, snapshot);
                            break;
                        case _firebaseNest.FB_CHILD_REMOVED:
                            removeChild(fbStore, sub, _getKey(snapshot));
                            break;
                    }
                } else {
                    //TODO error
                    console.error('[mobx-firebase-store] sub.asValue or sub.asList must be true');
                    console.error(sub);
                }

                validateTransforms(sub);

                var callback = sub.onData || (store.onData ? store.onData.bind(store) : null);
                if (callback) {
                    //Allow to react to data, for animations, snackbars, etc.
                    (0, _mobx.runInAction)(function () {
                        return callback(type, snapshot, sub);
                    });
                }
            }

            queue.add(call);
        },
        onSubscribed: function onSubscribed(sub) {
            if (store.onSubscribed) {
                queue.add(function () {
                    return store.onSubscribed(sub);
                });
            }
        },
        onUnsubscribed: function onUnsubscribed(subKey) {
            if (store.onUnsubscribed) {
                queue.add(function () {
                    return store.onUnsubscribed(subKey);
                });
            }
        },
        onWillSubscribe: function onWillSubscribe(sub) {
            //console.log('Subscribing ' + sub.subKey + ' path=' + sub.path);
            if (store.onWillSubscribe) {
                queue.add(function () {
                    return store.onWillSubscribe(sub);
                });
            }
        },

        onWillUnsubscribe: function onWillUnsubscribe(subKey) {
            //console.log('Unsubscribing ' + subKey + ' ref#=' + subscribedRegistry[subKey].refCount);
            if (store.onWillUnsubscribe) {
                queue.add(function () {
                    return store.onWillUnsubscribe(subKey);
                });
            }
        },

        resolveFirebaseQuery: function resolveFirebaseQuery(sub) {
            if (store.resolveFirebaseQuery) {
                return store.resolveFirebaseQuery(sub);
            }

            if (!sub || !sub.path && !sub.resolveFirebaseRef) {
                console.error('mobx-firebase-store] expects each sub to have a path or resolveFirebaseRef: ' + sub.subKey);
            }

            return sub.resolveFirebaseRef ? sub.resolveFirebaseRef() : fb.child(sub.path);
        }
    }),
        subscribeSubs = _createNestedFirebase.subscribeSubs,
        subscribedRegistry = _createNestedFirebase.subscribedRegistry,
        unsubscribeAll = _createNestedFirebase.unsubscribeAll,
        subscribeSubsWithPromise = _createNestedFirebase.subscribeSubsWithPromise;

    return { queue: queue, subscribeSubs: subscribeSubs, subscribedRegistry: subscribedRegistry, unsubscribeAll: unsubscribeAll, subscribeSubsWithPromise: subscribeSubsWithPromise };
}

function maybeDelayedUnsubscribe(unsubscribe, delayMs) {
    if (!delayMs) return unsubscribe;

    //New unsubscribe function that unsubscribes after a timeout
    return function () {
        return new Promise(function (resolve, reject) {
            setTimeout(function () {
                unsubscribe();
                resolve();
            }, delayMs);
        });
    };
}

var MobxFirebaseStore = function () {
    //TODO dependency injection of mobx & firebase-nest?

    function MobxFirebaseStore(fb, config) {
        _classCallCheck(this, MobxFirebaseStore);

        //data that will be populated directly from firebase
        this.fbStore = map({});

        this.unsubscribeDelayMs = (config || {}).unsubscribeDelayMs || 0;

        this.fb = fb; //a Firebase instance pointing to root URL for the app

        var _createFirebaseSubscr = createFirebaseSubscriber(this, this.fb, config),
            queue = _createFirebaseSubscr.queue,
            subscribeSubs = _createFirebaseSubscr.subscribeSubs,
            subscribedRegistry = _createFirebaseSubscr.subscribedRegistry,
            unsubscribeAll = _createFirebaseSubscr.unsubscribeAll,
            subscribeSubsWithPromise = _createFirebaseSubscr.subscribeSubsWithPromise;

        this.queue = queue;
        this.rawSubscribeSubs = subscribeSubs;
        this.rawSubscribeSubsWithPromise = subscribeSubsWithPromise;
        this.subscribeSubs = this.subscribeSubs.bind(this);
        this.subscribeSubsWithPromise = this.subscribeSubsWithPromise.bind(this);
        this.subscribedRegistry = subscribedRegistry;
        this.unsubscribeAll = unsubscribeAll;
    }

    _createClass(MobxFirebaseStore, [{
        key: 'subscribeSubs',
        value: function subscribeSubs(subs) {
            return maybeDelayedUnsubscribe(this.rawSubscribeSubs(subs), this.unsubscribeDelayMs);
        }
    }, {
        key: 'subscribeSubsWithPromise',
        value: function subscribeSubsWithPromise(subs) {
            var _this2 = this;

            var _rawSubscribeSubsWith = this.rawSubscribeSubsWithPromise(subs),
                unsubscribe = _rawSubscribeSubsWith.unsubscribe,
                promise = _rawSubscribeSubsWith.promise;

            //Put resolve/reject on the queue to make sure it is seen after queued-up onData callbacks


            var queuedResolvePromise = new Promise(function (resolve, reject) {
                promise.then(function (subKey) {
                    _this2.queue.add(function () {
                        return resolve(subKey);
                    });
                }, function (error) {
                    _this2.queue.add(function () {
                        return reject(error);
                    });
                });
            });

            return {
                unsubscribe: maybeDelayedUnsubscribe(unsubscribe, this.unsubscribeDelayMs),
                promise: queuedResolvePromise
            };
        }
    }, {
        key: 'getData',
        value: function getData(subKey) {
            return this.fbStore.get(subKey);
        }
    }, {
        key: 'reset',
        value: function reset() {
            var _this3 = this;

            this.queue.add(function () {
                _this3.unsubscribeAll();
                _this3.fbStore.clear();
            });
        }
    }, {
        key: 'resetFromData',
        value: function resetFromData(data) {
            var _this4 = this;

            this.fbStore.clear();
            Object.keys(data || {}).forEach(function (subKey) {
                var obsVal = void 0;
                var val = data[subKey];
                if (val !== null) {
                    if (Array.isArray(val)) {
                        obsVal = _mobx.observable.array(val);
                    } else if ((typeof val === 'undefined' ? 'undefined' : _typeof(val)) !== 'object') {
                        obsVal = _mobx.observable.map(_defineProperty({}, primitiveKey, val));
                    } else {
                        obsVal = _mobx.observable.map(val);
                    }
                }
                _this4.fbStore.set(subKey, obsVal);
            });
        }
    }, {
        key: 'toJS',
        value: function toJS() {
            return this.fbStore.toJS();
        }
    }, {
        key: 'onSubscribed',
        value: function onSubscribed(sub) {
            if (this.observableSubscriptionGraph) {
                this.observableSubscriptionGraph.update();
            }
        }
    }, {
        key: 'onUnsubscribed',
        value: function onUnsubscribed(subKey) {
            //Default implementation: remove data when it no longer has any subscribers

            if (!this.subscribedRegistry[subKey]) {
                this.fbStore.delete(subKey);
            }

            if (this.observableSubscriptionGraph) {
                this.observableSubscriptionGraph.update();
            }
        }
    }, {
        key: 'attachObservableSubscriptionGraph',
        value: function attachObservableSubscriptionGraph(graph) {
            this.observableSubscriptionGraph = graph;
        }
    }, {
        key: 'getSubscribedRegistry',
        value: function getSubscribedRegistry() {
            return this.subscribedRegistry;
        }
    }]);

    return MobxFirebaseStore;
}();

var ObservableSubscriptionGraph = exports.ObservableSubscriptionGraph = function () {
    function ObservableSubscriptionGraph(store, makeNodeProps) {
        _classCallCheck(this, ObservableSubscriptionGraph);

        this.store = store;
        this.obsGraph = (0, _mobx.observable)({
            nodes: [],
            edges: []
        });

        this.makeNodeProps = makeNodeProps;

        store.attachObservableSubscriptionGraph(this);
    }

    //to be called by MobxFirebaseStore internally


    _createClass(ObservableSubscriptionGraph, [{
        key: 'update',
        value: function update() {
            var graph = (0, _firebaseNest.asNodesAndEdges)(this.store.getSubscribedRegistry(), this.makeNodeProps);
            this.obsGraph.nodes.replace(graph.nodes);
            this.obsGraph.edges.replace(graph.edges);
        }
    }, {
        key: 'get',
        value: function get() {
            return {
                nodes: this.obsGraph.nodes.slice(),
                edges: this.obsGraph.edges.slice()
            };
        }
    }]);

    return ObservableSubscriptionGraph;
}();

exports.default = MobxFirebaseStore;