'use strict';

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.defaultMakeVisNodeProps = exports.asNodesAndEdges = exports.asDotGraph = exports.createAutoSubscriber = exports.autoSubscriber = exports.FB_VALUE = exports.FB_CHILD_CHANGED = exports.FB_CHILD_WILL_CHANGE = exports.FB_CHILD_REMOVED = exports.FB_CHILD_WILL_REMOVE = exports.FB_CHILD_ADDED = exports.FB_INIT_VAL = undefined;

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

var _autoSubscriber = require('./autoSubscriber');

Object.defineProperty(exports, 'createAutoSubscriber', {
    enumerable: true,
    get: function get() {
        return _autoSubscriber.createAutoSubscriber;
    }
});

var _subscriptionGraph = require('./subscriptionGraph');

Object.defineProperty(exports, 'asDotGraph', {
    enumerable: true,
    get: function get() {
        return _subscriptionGraph.asDotGraph;
    }
});
Object.defineProperty(exports, 'asNodesAndEdges', {
    enumerable: true,
    get: function get() {
        return _subscriptionGraph.asNodesAndEdges;
    }
});
Object.defineProperty(exports, 'defaultMakeVisNodeProps', {
    enumerable: true,
    get: function get() {
        return _subscriptionGraph.defaultMakeVisNodeProps;
    }
});
exports.default = createSubscriber;

var _autoSubscriber2 = _interopRequireDefault(_autoSubscriber);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } else { return Array.from(arr); } }

//list data
var FB_INIT_VAL = exports.FB_INIT_VAL = 'FB_INIT_VAL';
var FB_CHILD_ADDED = exports.FB_CHILD_ADDED = 'FB_CHILD_ADDED';
var FB_CHILD_WILL_REMOVE = exports.FB_CHILD_WILL_REMOVE = 'FB_CHILD_WILL_REMOVE';
var FB_CHILD_REMOVED = exports.FB_CHILD_REMOVED = 'FB_CHILD_REMOVED';
var FB_CHILD_WILL_CHANGE = exports.FB_CHILD_WILL_CHANGE = 'FB_CHILD_WILL_CHANGE';
var FB_CHILD_CHANGED = exports.FB_CHILD_CHANGED = 'FB_CHILD_CHANGED';
//value data
var FB_VALUE = exports.FB_VALUE = 'FB_VALUE';
var autoSubscriber = exports.autoSubscriber = _autoSubscriber2.default;

//credit to js-promise-defer on github
function defer(deferred) {
    deferred.promise = new Promise(function (resolve, reject) {
        deferred.resolve = resolve;
        deferred.reject = reject;
    });
}
function fieldSubsToForFields(sub) {
    var fieldSubs = sub.fieldSubs;
    if (!fieldSubs) return [];
    return Object.keys(fieldSubs || {}).map(function (key) {
        var getFieldSubs = fieldSubs[key];
        return {
            fieldKey: key,
            fieldSubs: getFieldSubs
        };
    });
}
//To detect subscriber cycles, keep track of which subscribes are done from "outside" as parentSubKey="_root".
//The rest of subscribes are due to subscribing to child data.
var rootSubKey = '_root';
//Firebase 3.x: snapshot.key() has been replaced with snapshot.key
var _getKey = function getKey(snapshot) {
    if (typeof snapshot.key == 'function') {
        console.log('firebase-nest: detected pre-3.x firebase snapshot.key()');
        _getKey = legacyGetKey;
        return legacyGetKey(snapshot);
    }
    console.log('firebase-nest: detected ^3.x firebase snapshot.key');
    _getKey = newGetKey;
    return newGetKey(snapshot);
};
function legacyGetKey(snapshot) {
    return snapshot.key();
}
function newGetKey(snapshot) {
    return snapshot.key;
}
function createSubscriber(_ref) {
    var onData = _ref.onData,
        onSubscribed = _ref.onSubscribed,
        onUnsubscribed = _ref.onUnsubscribed,
        resolveFirebaseQuery = _ref.resolveFirebaseQuery,
        onWillSubscribe = _ref.onWillSubscribe,
        onWillUnsubscribe = _ref.onWillUnsubscribe,
        onError = _ref.onError,
        doNotDetectCycles = _ref.doNotDetectCycles;

    function reportError(error) {
        if (onError && typeof onError === 'function') {
            onError(error);
        }
    }
    //let disallowSubscriptions = false;
    var subscribedRegistry = {};
    var promisesBySubKey = {};
    var self = {
        subscribeSubsWithPromise: subscribeSubsWithPromise
    };
    function loadedPromise(subKey) {
        if (promisesBySubKey[subKey]) {
            return promisesBySubKey[subKey].promise;
        }
        promisesBySubKey[subKey] = {};
        defer(promisesBySubKey[subKey]);
        return promisesBySubKey[subKey].promise;
    }
    function subsLoaded(subs) {
        return Promise.all((subs || []).map(function (sub) {
            return loadedPromise(sub.subKey);
        }));
    }
    if (!onData || !resolveFirebaseQuery) {
        console.error('createNestedFirebaseSubscriber: missing onData or resolveFirebaseQuery callback');
        return;
    }
    function subscribeToField(sub, forField, fieldKey, fieldVal, promises) {
        var store = forField.store ? forField.store : self;
        var fieldSubs = forField.fieldSubs.apply(forField, [fieldVal].concat(_toConsumableArray(forField.args || []))) || [];

        var _store$subscribeSubsW = store.subscribeSubsWithPromise(fieldSubs, sub.subKey),
            unsubscribe = _store$subscribeSubsW.unsubscribe,
            promise = _store$subscribeSubsW.promise;

        if (!subscribedRegistry[sub.subKey]) {
            //edge case - roll back subscribe if somehow our parent got unsubscribed by on* callbacks
            unsubscribe();
            return;
        }
        ;
        subscribedRegistry[sub.subKey].fieldUnsubs[fieldKey] = unsubscribe;
        if (promises) {
            promises.push(promise);
        }
    }
    function subscribeToFields(sub, val, promises) {
        if (!subscribedRegistry[sub.subKey]) return;
        var oldFieldUnsubs = _extends({}, subscribedRegistry[sub.subKey].fieldUnsubs || {});
        subscribedRegistry[sub.subKey].fieldUnsubs = {};
        //Subscribe based on new fields in val
        var forFields = (sub.fieldSubs ? fieldSubsToForFields(sub) : sub.forFields) || [];
        if (forFields.constructor !== Array) {
            console.error('ERROR: forFields must be an array: ', forFields);
        } else {
            if (val !== null && (typeof val === 'undefined' ? 'undefined' : _typeof(val)) == 'object') {
                val = val || {};
                (forFields || []).forEach(function (forField) {
                    if (!forField.fieldKey || !forField.fieldSubs) {
                        console.error('ERROR: each element in forFields must have fieldKey and fieldSubs keys');
                        return;
                    }
                    var fieldVal = val[forField.fieldKey];
                    if (fieldVal !== undefined) {
                        subscribeToField(sub, forField, forField.fieldKey, fieldVal, promises);
                    }
                });
            }
        }
        //Unsubscribe old fields
        Object.keys(oldFieldUnsubs || {}).forEach(function (field) {
            var unsub = oldFieldUnsubs[field];
            unsub();
        });
    }
    function subscribeToChildData(sub, childKey, childVal, promises) {
        if (!sub.forEachChild && !sub.childSubs) return;
        var getChildSubs = sub.forEachChild ? sub.forEachChild.childSubs : sub.childSubs;
        if (!getChildSubs) {
            console.error('ERROR: forEachChild must have a childSubs key - a function that returns a subs array and takes a \n                        childKey and other optional args specified in forEachChild.args');
        }
        var store = sub.forEachChild && sub.forEachChild.store ? sub.forEachChild.store : self;
        var childSubs = (sub.forEachChild ? getChildSubs.apply(undefined, [childKey].concat(_toConsumableArray(sub.forEachChild.args || []), [childVal])) : getChildSubs(childKey, childVal)) || [];

        var _store$subscribeSubsW2 = store.subscribeSubsWithPromise(childSubs, sub.subKey),
            unsubscribe = _store$subscribeSubsW2.unsubscribe,
            promise = _store$subscribeSubsW2.promise;

        if (!subscribedRegistry[sub.subKey]) {
            //roll back if parent got unsubscribed by on* callbacks
            unsubscribe();
            return;
        }
        ;
        subscribedRegistry[sub.subKey].childUnsubs[childKey] = unsubscribe;
        if (promises) {
            promises.push(promise);
        }
    }
    function check(type, sub) {
        if (!subscribedRegistry[sub.subKey]) {
            console.error('Error for ' + sub.subKey + ', got ' + type + ' firebase callback but not subscribed!');
            return false;
        }
        return true;
    }
    function handleFbError(sub) {
        return function (error) {
            if (subscribedRegistry[sub.subKey]) {
                var path = sub.path ? sub.path + ' ' : '';
                var errorCode = sub.subKey + ' ' + path + 'Firebase error: ' + ((error || {}).code || 'unknown error');
                reportError(errorCode);
                if (promisesBySubKey[sub.subKey]) {
                    promisesBySubKey[sub.subKey].reject(errorCode);
                }
            }
        };
    }
    function detectAndReportSubscribeCycle(subKey) {
        //Check whether this subKey has itself in the parent chain, and if so, reject the promise
        var trail = detectSubscribeCycle(subKey, Object.keys(subscribedRegistry[subKey].parentSubKeys), [subKey], {});
        if (trail) {
            var error = 'Cycle detected: ' + trail.join('<-');
            //If there's a cycle (for ex. subKey A subscribed B which subscribed A), we will never resolve, so reject the Promise
            //TODO only reject if we haven't yet resolved
            if (promisesBySubKey[subKey]) {
                promisesBySubKey[subKey].reject(error);
            }
            reportError(error);
        }
    }
    function executeListSubscribeAction(sub, parentSubKey) {
        if (subscribedRegistry[sub.subKey]) {
            //Already subscribed, just increment ref count
            subscribedRegistry[sub.subKey].refCount++;
            if (parentSubKey) {
                var parentSubKeys = subscribedRegistry[sub.subKey].parentSubKeys;
                if (!parentSubKeys[parentSubKey]) {
                    parentSubKeys[parentSubKey] = 1;
                } else {
                    parentSubKeys[parentSubKey]++;
                }
            }
            //Check whether this subKey has itself in the parent chain, and if so, reject the promise
            if (!doNotDetectCycles) {
                detectAndReportSubscribeCycle(sub.subKey);
            }
            return;
        }
        var ref = resolveFirebaseQuery(sub);
        var gotInitVal = false;
        subscribedRegistry[sub.subKey] = {
            refCount: 1,
            ref: ref,
            parentSubKeys: {},
            childUnsubs: {},
            fieldUnsubs: {},
            refHandles: {}
        };
        if (parentSubKey) {
            subscribedRegistry[sub.subKey].parentSubKeys[parentSubKey] = 1;
        }
        loadedPromise(sub.subKey);
        var thePromise = promisesBySubKey[sub.subKey];
        var errorHandler = handleFbError(sub);
        subscribedRegistry[sub.subKey].refHandles.child_added = ref.on('child_added', function (snapshot) {
            if (!gotInitVal) return;
            if (!check('child_added', sub)) return;
            subscribeToChildData(sub, _getKey(snapshot), snapshot.val());
            onData(FB_CHILD_ADDED, snapshot, sub);
        }, errorHandler);
        subscribedRegistry[sub.subKey].refHandles.child_changed = ref.on('child_changed', function (snapshot) {
            if (!gotInitVal) return;
            if (!check('child_changed', sub)) return;
            //Since we pass snapshot.val() to childSubs, it might use it, so we need call it when snapshot.val()
            //changes
            var childUnsub = subscribedRegistry[sub.subKey].childUnsubs[_getKey(snapshot)];
            subscribeToChildData(sub, _getKey(snapshot), snapshot.val());
            if (childUnsub) childUnsub();
            onData(FB_CHILD_WILL_CHANGE, snapshot, sub);
            onData(FB_CHILD_CHANGED, snapshot, sub);
        }, errorHandler);
        subscribedRegistry[sub.subKey].refHandles.child_removed = ref.on('child_removed', function (snapshot) {
            if (!gotInitVal) return;
            if (!check('child_removed', sub)) return;
            var childUnsub = subscribedRegistry[sub.subKey].childUnsubs[_getKey(snapshot)];
            delete subscribedRegistry[sub.subKey].childUnsubs[_getKey(snapshot)];
            if (childUnsub) childUnsub();
            onData(FB_CHILD_WILL_REMOVE, snapshot, sub);
            onData(FB_CHILD_REMOVED, snapshot, sub);
        }, errorHandler);
        ref.once('value', function (snapshot) {
            if (gotInitVal) {
                console.error("Got 'once' callback for " + _getKey(snapshot) + " more than once");
                return;
            }
            gotInitVal = true;
            //We might've gotten unsubscribed while waiting for initial value, so check if we're still subscribed
            if (subscribedRegistry[sub.subKey]) {
                var val = snapshot.val();
                var nestedPromises = [];
                if (val !== null && (typeof val === 'undefined' ? 'undefined' : _typeof(val)) == 'object') {
                    Object.keys(val).forEach(function (childKey) {
                        return subscribeToChildData(sub, childKey, val[childKey], nestedPromises);
                    });
                }
                onData(FB_INIT_VAL, snapshot, sub);
                if (!subscribedRegistry[sub.subKey]) {
                    //no longer subscribed (onData callback could've unsubscribed us)
                    return;
                }
                //Once all initial child & field promises are resolved, we can resolve ourselves
                Promise.all(nestedPromises).then(function () {
                    thePromise.resolve(sub.subKey);
                }, function (error) {
                    thePromise.reject(error);
                });
            }
        }, errorHandler);
    }
    function executeValueSubscribeAction(sub, parentSubKey) {
        if (subscribedRegistry[sub.subKey]) {
            //Already subscribed, just increment ref count
            subscribedRegistry[sub.subKey].refCount++;
            if (parentSubKey) {
                var parentSubKeys = subscribedRegistry[sub.subKey].parentSubKeys;
                if (!parentSubKeys[parentSubKey]) {
                    parentSubKeys[parentSubKey] = 1;
                } else {
                    parentSubKeys[parentSubKey]++;
                }
            }
            //Check whether this subKey has itself in the parent chain, and if so, reject the promise
            if (!doNotDetectCycles) {
                detectAndReportSubscribeCycle(sub.subKey);
            }
            return;
        }
        var ref = resolveFirebaseQuery(sub);
        subscribedRegistry[sub.subKey] = {
            sub: sub,
            refCount: 1,
            ref: ref,
            parentSubKeys: {},
            childUnsubs: {},
            fieldUnsubs: {},
            refHandles: {}
        };
        if (parentSubKey) {
            subscribedRegistry[sub.subKey].parentSubKeys[parentSubKey] = 1;
        }
        loadedPromise(sub.subKey);
        var thePromise = promisesBySubKey[sub.subKey];
        var resolved = false;
        var errorHandler = handleFbError(sub);
        subscribedRegistry[sub.subKey].refHandles.value = ref.on('value', function (snapshot) {
            if (!check('value', sub)) return;
            //First subscribe to new value's nodes, then unsubscribe old ones - the ones in both old/new will remain
            //subscribed to firebase to avoid possibly blowing away firebase cache
            var oldChildUnsubs = _extends({}, subscribedRegistry[sub.subKey].childUnsubs);
            subscribedRegistry[sub.subKey].childUnsubs = {};
            var nestedPromises = resolved ? null : [];
            var val = snapshot.val();
            if (val !== null && (typeof val === 'undefined' ? 'undefined' : _typeof(val)) == 'object') {
                Object.keys(val).forEach(function (childKey) {
                    return subscribeToChildData(sub, childKey, val[childKey], nestedPromises);
                });
            }
            Object.keys(oldChildUnsubs || {}).forEach(function (childKey) {
                var childUnsub = oldChildUnsubs[childKey];
                childUnsub();
            });
            subscribeToFields(sub, val, nestedPromises);
            onData(FB_VALUE, snapshot, sub);
            if (!resolved) {
                resolved = true;
                if (!subscribedRegistry[sub.subKey]) {
                    //no longer subscribed (onData callback could've unsubscribed us)
                    return;
                }
                //Once all initial child & field promises are resolved, we can resolve ourselves
                Promise.all(nestedPromises).then(function () {
                    thePromise.resolve(sub.subKey);
                }, function (error) {
                    thePromise.reject(error);
                });
            }
        }, errorHandler);
    }
    function unsubscribeSubKey(subKey, parentSubKey) {
        // if (disallowSubscriptions) {
        //     reportError("Not allowed to unsubscribe within onSubscribed/onWillSubscribe/onUnsubscribed/onWillUnsubscribe callbacks");
        //     return false;
        // }
        var info = subscribedRegistry[subKey];
        if (!info) {
            console.error('no subscriber found for subKey=' + subKey);
        } else {
            // disallowSubscriptions = true;
            if (onWillUnsubscribe) onWillUnsubscribe(subKey);
            // disallowSubscriptions = false;
            info.refCount--;
            if (parentSubKey) {
                if (info.parentSubKeys[parentSubKey] && info.parentSubKeys[parentSubKey] > 0) {
                    info.parentSubKeys[parentSubKey]--;
                    if (info.parentSubKeys[parentSubKey] <= 0) {
                        delete info.parentSubKeys[parentSubKey];
                    }
                }
            }
            if (info.refCount <= 0) {
                delete subscribedRegistry[subKey];
                delete promisesBySubKey[subKey];
                Object.keys(info.refHandles).forEach(function (eventType) {
                    info.ref.off(eventType, info.refHandles[eventType]);
                });
                Object.keys(info.childUnsubs || {}).forEach(function (childKey) {
                    var childUnsub = info.childUnsubs[childKey];
                    childUnsub();
                });
                Object.keys(info.fieldUnsubs || {}).forEach(function (fieldKey) {
                    var fieldUnsub = info.fieldUnsubs[fieldKey];
                    fieldUnsub();
                });
            }
        }
        // disallowSubscriptions = true;
        if (onUnsubscribed) onUnsubscribed(subKey);
        // disallowSubscriptions = false;
    }
    function detectSubscribeCycle(subKey, parentSubKeys, trail, checked) {
        if (!parentSubKeys || parentSubKeys.length == 0) return false;
        var index = (parentSubKeys || []).indexOf(subKey);
        if (index >= 0) {
            return [].concat(_toConsumableArray(trail), [parentSubKeys[index]]);
        }
        var found = parentSubKeys.some(function (parentSubKey) {
            if (checked[parentSubKey]) return false;
            checked[parentSubKey] = true;
            var res = detectSubscribeCycle(subKey, Object.keys((subscribedRegistry[parentSubKey] || {}).parentSubKeys || {}), [].concat(_toConsumableArray(trail), [parentSubKey]), checked);
            if (res) {
                trail = res;
                return true;
            }
            return false;
        });
        return found ? trail : false;
    }
    function subscribeSub(sub) {
        var parentSubKey = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : rootSubKey;

        // if (disallowSubscriptions) {
        //     reportError("Not allowed to subscribe within onSubscribed/onWillSubscribe/onUnsubscribed/onWillUnsubscribe callbacks");
        //     return () => false;
        // }
        if (!sub.subKey) {
            console.error('subscribeSub needs an object with a string subKey field');
            console.error(sub);
            return;
        }
        if (!sub.asList && !sub.asValue) {
            console.error('subscribeSub needs an object with either asList=true or asValue=true');
            console.error(sub);
            return;
        }
        // disallowSubscriptions = true;
        if (onWillSubscribe) onWillSubscribe(sub);
        // disallowSubscriptions = false;
        if (sub.asList) {
            executeListSubscribeAction(sub, parentSubKey);
        } else if (sub.asValue) {
            executeValueSubscribeAction(sub, parentSubKey);
        } else {
            console.error('sub must have asList or asValue = true');
        }
        // disallowSubscriptions = true;
        if (onSubscribed) onSubscribed(sub);
        // disallowSubscriptions = false;
        return function unsubscribe() {
            unsubscribeSubKey(sub.subKey, parentSubKey);
        };
    }
    function subscribeSubs(subs) {
        var parentSubKey = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : rootSubKey;

        if (!subs) return;
        if (!subs.forEach) {
            console.error('subscribeSubs expects an array of subs');
            console.error(subs);
            return;
        }
        var unsubs = subs.map(function (sub) {
            return subscribeSub(sub, parentSubKey);
        });
        return function unsubscribe() {
            unsubs.forEach(function (unsub) {
                return unsub();
            });
        };
    }
    function subscribeSubsWithPromise(subs) {
        var parentSubKey = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : rootSubKey;

        if (!subs) return;
        if (!subs.forEach) {
            console.error('subscribeSubs expects an array of subs');
            console.error(subs);
            return;
        }
        var unsubs = subs.map(function (sub) {
            return subscribeSub(sub, parentSubKey);
        });
        return {
            unsubscribe: function unsubscribe() {
                unsubs.forEach(function (unsub) {
                    return unsub();
                });
            },
            promise: subsLoaded(subs)
        };
    }
    function unsubscribeAll() {
        for (var subKey in subscribedRegistry) {
            var sub = subscribedRegistry[subKey];
            var numRootSubscribes = (sub.parentSubKeys || {})[rootSubKey] || 0;
            for (var i = 0; i < numRootSubscribes; i++) {
                unsubscribeSubKey(subKey);
            }
        }
    }
    return { subscribeSubs: subscribeSubs, subscribedRegistry: subscribedRegistry, unsubscribeAll: unsubscribeAll, subscribeSubsWithPromise: subscribeSubsWithPromise, loadedPromise: loadedPromise };
}
;