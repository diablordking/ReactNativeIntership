'use strict';

Object.defineProperty(exports, "__esModule", {
    value: true
});

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

exports.defaultMakeVisNodeProps = defaultMakeVisNodeProps;
exports.asNodesAndEdges = asNodesAndEdges;
exports.asDotGraph = asDotGraph;
//default way to make a graph node from subInfo
//for properties you can output, see http://visjs.org/docs/network/nodes.html
function defaultMakeVisNodeProps(subKey, subInfo) {
    subInfo = subInfo || {};
    var sub = subInfo.sub || {};
    var firebasePath = sub.path || (subInfo.ref || {}).ref || '';
    var label = firebasePath + ' \n ' + subKey + ' \n # subsribers: ' + (subInfo.refCount || 0);
    if (subInfo.childUnsubs) {
        label += '\n # children subs: ' + Object.keys(subInfo.childUnsubs).length;
    }
    if (subInfo.fieldUnsubs) {
        label += '\n # field subs: ' + Object.keys(subInfo.fieldUnsubs).length;
    }
    return { shape: 'box', borderWidth: 1, shadow: { enabled: true }, color: { background: '#D2E5FF', border: 'grey' }, label: label };
}
function asNodesAndEdges(subscribedRegistry, makeVisNodeProps) {
    makeVisNodeProps = makeVisNodeProps || defaultMakeVisNodeProps;
    var subKeys = {};
    var nodes = [];
    var edges = [];
    Object.keys(subscribedRegistry || {}).forEach(function (subKey) {
        var subInfo = subscribedRegistry[subKey];
        var node = _extends({}, makeVisNodeProps(subKey, subInfo), { id: subKey });
        subKeys[subKey] = node;
        nodes.push(node);
    });
    Object.keys(subscribedRegistry || {}).forEach(function (subKey) {
        var subInfo = subscribedRegistry[subKey] || {};
        var node = subKeys[subKey];
        Object.keys(subInfo.parentSubKeys || {}).forEach(function (parentSubKey) {
            if (subKeys[parentSubKey]) {
                edges.push({ length: 5, from: parentSubKey, to: subKey });
                if (!node.group) {
                    node.group = parentSubKey;
                }
            } else {}
        });
    });
    return {
        nodes: nodes,
        edges: edges
    };
}
function visNodeToDotNode(node) {
    var fillColor = node.color && typeof node.color === 'string' ? ' style=filled fillcolor="' + node.color + '"' : node.color && node.color.background ? ' style=filled fillcolor="' + node.color.background + '"' : '';
    var borderColor = node.color && node.color.border ? ' color="' + node.color.border + '"' : '';
    return node.id + ' [label="' + node.label + '"' + fillColor + borderColor + ']';
}
function visEdgeToDotEdge(edge) {
    return edge.from + ' -> ' + edge.to;
}
function asDotGraph(subscribedRegistry, makeNodeProps) {
    var opts = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};

    var visGraph = asNodesAndEdges(subscribedRegistry, makeNodeProps);
    //const nodesById = visGraph.nodes.reduce((byId, node) => (Object.assign({}, byId, {[node.id]: node})), {});
    var _opts$name = opts.name,
        name = _opts$name === undefined ? 'SubscriptionGraph' : _opts$name;

    return 'digraph "' + name + '" { ' + visGraph.nodes.map(function (node) {
        return visNodeToDotNode(node);
    }).join(' ;\n') + ' ;\n' + visGraph.edges.map(function (edge) {
        return visEdgeToDotEdge(edge);
    }).join(' ;\n') + ' ;\n' + ' }';
}